# Algorithms



Maximum Pairwise Product
========================
Find the maximum product of two distinct numbers in a sequence of non-negative integers.
Input: A sequence of non-negative integers.
Output: The maximum value that can be obtained by multiplying two different elements from the sequence.
Input format: The first line contains an integer ğ‘›. The next line contains n non-negative integers a1, ..., an (separated by spaces).
Output format: The maximum pairwise product.
Constraints: 2 < ğ‘› < 2 *10^5; 0 < a1, ..., an < 2*10^5.



Fibonacci Number
================
Given an integer ğ‘›, find the ğ‘›th Fibonacci number ğ¹ğ‘›.
Input Format: The input consists of a single integer ğ‘›.
Constraints: 0 â‰¤ ğ‘› â‰¤ 45.
Output Format: Output ğ¹ğ‘›.



Last Digit of a Large Fibonacci Number
======================================
Given an integer ğ‘›, find the last digit of the ğ‘›th Fibonacci number ğ¹ğ‘› (that is, ğ¹ğ‘› mod 10).
Input Format: The input consists of a single integer ğ‘›.
Constraints: 0 â‰¤ ğ‘› â‰¤ 10^7.
Output Format: Output the last digit of ğ¹ğ‘›.



Greatest Common Divisor
=======================
Given two integers ğ‘ and ğ‘, find their greatest common divisor.
Input Format: The two integers ğ‘, ğ‘ are given in the same line separated by space.
Constraints: 1 â‰¤ ğ‘, ğ‘ â‰¤ 2 Â· 10^9.
Output Format: Output GCD(ğ‘, ğ‘).



Least Common Multiple
=====================
Given two integers ğ‘ and ğ‘, find their least common multiple.
Input Format: The two integers ğ‘ and ğ‘ are given in the same line separated by space.
Constraints: 1 â‰¤ ğ‘, ğ‘ â‰¤ 10^7.
Output Format: Output the least common multiple of ğ‘ and ğ‘.




Fibonacci Number mode ğ‘š
========================
Given two integers ğ‘› and ğ‘š, output ğ¹ğ‘› mod ğ‘š (that is, the remainder of ğ¹ğ‘› when divided by ğ‘š).
Input Format: The input consists of two integers ğ‘› and ğ‘š given on the same line (separated by a space).
Constraints: 1 â‰¤ ğ‘› â‰¤ 10^14, 2 â‰¤ ğ‘š â‰¤ 10^3.
Output Format: Output ğ¹ğ‘› mod ğ‘š.



Last Digit of the Sum of Fibonacci Numbers
==========================================
Given an integer ğ‘›, find the last digit of the sum ğ¹0 + ğ¹1 + Â· Â· Â· + ğ¹ğ‘›.
Input Format: The input consists of a single integer ğ‘›.
Constraints: 0 â‰¤ ğ‘› â‰¤ 10^14.
Output Format: Output the last digit of ğ¹0 + ğ¹1 + Â· Â· Â· + ğ¹ğ‘›.



Last Digit of the Sum of Fibonacci Numbers
==========================================
Given two non-negative integers ğ‘š and ğ‘›, where ğ‘š â‰¤ ğ‘›, find the last digit of the sum ğ¹ğ‘š + ğ¹ğ‘š+1 + Â· Â· Â· + ğ¹ğ‘›.
Input Format: The input consists of two non-negative integers ğ‘š and ğ‘› separated by a space.
Constraints: 0 â‰¤ ğ‘š â‰¤ ğ‘› â‰¤ 10^14.
Output Format: Output the last digit of ğ¹ğ‘š + ğ¹ğ‘š+1 + Â· Â· Â· + ğ¹ğ‘›.




Last Digit of the Sum of Squares of Fibonacci Numbers
=====================================================
Compute the last digit of ğ¹0^2 + ğ¹1^2 + Â· Â· Â· + ğ¹ğ‘›^2.
Input Format: Integer ğ‘›.
Constraints: 0 â‰¤ ğ‘› â‰¤ 10^14.
Output Format: The last digit of ğ¹0^2 + ğ¹1^2 + Â· Â· Â· + ğ¹ğ‘›^2.



Money Change
============
Finding the minimum number of coins needed to change the input value (an integer) into coins with denominations 1, 5, and 10.
Input Format: The input consists of a single integer ğ‘š.
Constraints: 1 â‰¤ ğ‘š â‰¤ 10^3.
Output Format: Output the minimum number of coins with denominations 1, 5, 10 that changes ğ‘š.



Fractional Knapsack
===================
Input Format: The first line of the input contains the number ğ‘› of items and the capacity ğ‘Š of a knapsack. The next ğ‘› lines define the values and weights of the items. The ğ‘–-th line contains integers ğ‘£ğ‘– and ğ‘¤ğ‘– â€” the value and the weight of ğ‘–-th item, respectively.
Constraints: 1 â‰¤ ğ‘› â‰¤ 10^3, 0 â‰¤ ğ‘Š â‰¤ 2*10^6; 0 â‰¤ ğ‘£ğ‘– â‰¤ 2*10^6, 0 < ğ‘¤ğ‘– â‰¤ 2*10^6 for all 1 â‰¤ ğ‘– â‰¤ ğ‘›. All the numbers are integers.
Output Format: Output the maximal value of fractions of items that fit into the knapsack.



Car Fueling
===========
the minimum number of refills needed to travel to another city that is located ğ‘‘ miles away. Your car can travel at most ğ‘š miles on a full tank and you start with a full tank. Along your way, there are gas stations at distances stop1, stop2, . . . , stopğ‘› from your home city.
Input Format: The first line contains an integer ğ‘‘. The second line contains an integer ğ‘š. The third line specifies an integer ğ‘›. Finally, the last line contains integers stop1, stop2, . . . , stopğ‘›.
Output Format: The minimum number of refills needed. If it is not possible to reach the destination, output âˆ’1.
Constraints: 1 â‰¤ ğ‘‘ â‰¤ 10^5. 1 â‰¤ ğ‘š â‰¤ 400. 1 â‰¤ ğ‘› â‰¤ 300. 0 < stop1 < stop2 < Â· Â· Â· < stopğ‘› < ğ‘‘.



Maximum Number of Prizes
========================
The goal is to represent a given positive integer ğ‘› as a sum of as many pairwise distinct positive integers as possible. That is, to find the maximum ğ‘˜ such that ğ‘› can be written as ğ‘1 + ğ‘2 + Â· Â· Â· + ğ‘ğ‘˜ where ğ‘1, . . . , ğ‘ğ‘˜ are positive integers and ğ‘ğ‘– Ì¸= ğ‘ğ‘— for all 1 â‰¤ ğ‘– < ğ‘— â‰¤ ğ‘˜.
Input Format: The input consists of a single integer ğ‘›.
Constraints: 1 â‰¤ ğ‘› â‰¤ 10^9.
Output Format: In the first line, output the maximum number ğ‘˜ such that ğ‘› can be represented as a sum of ğ‘˜ pairwise distinct positive integers. In the second line, output ğ‘˜ pairwise distinct positive integers that sum up to ğ‘›.



Largest Number
==============
Composing the largest number out of the given single-digit numbers.
Input Format: The first line of the input contains integers ğ‘1, ğ‘2, . . . , ğ‘ğ‘›.
Constraints: 1 â‰¤ ğ‘› â‰¤ 100; 1 â‰¤ ğ‘ğ‘– â‰¤ 10^3 for all 1 â‰¤ ğ‘– â‰¤ ğ‘›.
Output Format: Output the largest number that can be composed out of ğ‘1, ğ‘2, . . . , ğ‘ğ‘›.



Binary Search
=============
The goal is to implement the binary search algorithm.
Input Format: The first line of the input contains an integer ğ‘› and a sequence ğ‘0 < ğ‘1 < . . . < ğ‘ğ‘›âˆ’1 of ğ‘› pairwise distinct positive integers in increasing order. The next line contains an integer ğ‘˜ and ğ‘˜ positive integers ğ‘0, ğ‘1, . . . , ğ‘ğ‘˜âˆ’1.
Constraints: 1 â‰¤ ğ‘˜ â‰¤ 10^5; 1 â‰¤ ğ‘› â‰¤ 3*10^4; 1 â‰¤ ğ‘ğ‘– â‰¤ 109 for all 0 â‰¤ ğ‘– < ğ‘›; 1 â‰¤ ğ‘ğ‘— â‰¤ 10^9 for all 0 â‰¤ ğ‘— < ğ‘˜;
Output Format: For all ğ‘– from 0 to ğ‘˜ âˆ’ 1, output an index 0 â‰¤ ğ‘— â‰¤ ğ‘› âˆ’ 1 such that ğ‘ğ‘— = ğ‘ğ‘– or âˆ’1 if there is no such index.



Majority Element
================
The goal is to check whether an input sequence contains a majority element, that is, repeated more than fifty percent.
Input Format: The first line contains an integer ğ‘›, the next one contains a sequence of ğ‘› non-negative integers ğ‘0, ğ‘1, . . . , ğ‘ğ‘›âˆ’1.
Constraints: 1 â‰¤ ğ‘› â‰¤ 10^5; 0 â‰¤ ğ‘ğ‘– â‰¤ 10^9 for all 0 â‰¤ ğ‘– < ğ‘›.
Output Format: Output 1 if the sequence contains an element that appears strictly more than ğ‘›/2 times, and 0 otherwise.



3-Way Quick Sort Algorithm
==========================
The goal is to replace a 2-way partition with a 3-way partition in quick sort algorithm. That is, the new partition procedure should partition the array into three parts: < ğ‘¥ part, = ğ‘¥ part, and > ğ‘¥ part.
Input Format: The first line of the input contains an integer ğ‘›. The next line contains a sequence of ğ‘› integers ğ‘0, ğ‘1, . . . , ğ‘ğ‘›âˆ’1.
Constraints: 1 â‰¤ ğ‘› â‰¤ 10^5; 1 â‰¤ ğ‘ğ‘– â‰¤ 10^9 for all 0 â‰¤ ğ‘– < ğ‘›.
Output Format: Output this sequence sorted in non-decreasing order.



Number of Inversions
====================
An inversion of a sequence ğ‘0, ğ‘1, . . . , ğ‘ğ‘›âˆ’1 is a pair of indices 0 â‰¤ ğ‘– < ğ‘— < ğ‘› such that ğ‘ğ‘– > ğ‘ğ‘— . For example, a sorted (in non-descending order) sequence contains no inversions at all, while in a sequence sorted in descending order any two elements constitute an inversion (for a total of ğ‘›(ğ‘› âˆ’ 1)/2 inversions).
The goal is to count the number of inversions of a given sequence.
Input Format: The first line contains an integer ğ‘›, the next one contains a sequence of integers ğ‘0, ğ‘1, . . . , ğ‘ğ‘›âˆ’1.
Constraints: 1 â‰¤ ğ‘› â‰¤ 10^5, 1 â‰¤ ğ‘ğ‘– â‰¤ 10^9 for all 0 â‰¤ ğ‘– < ğ‘›.
Output Format: Output the number of inversions in the sequence.



Points and Segments
===================
Given a set of points on a line and a set of segments on a line, the goal is to compute, for each point, the number of segments that contain this point.
Input Format: The first line contains two non-negative integers ğ‘  and ğ‘ defining the number of segments and the number of points on a line, respectively. The next ğ‘  lines contain two integers ğ‘ğ‘–, ğ‘ğ‘– defining the ğ‘–-th segment [ğ‘ğ‘–, ğ‘ğ‘–]. The next line contains ğ‘ integers defining points ğ‘¥1, ğ‘¥2, . . . , ğ‘¥ğ‘.
Constraints: 1 â‰¤ ğ‘ , ğ‘ â‰¤ 50000; âˆ’10^8 â‰¤ ğ‘ğ‘– â‰¤ ğ‘ğ‘– â‰¤ 10^8 for all 0 â‰¤ ğ‘– < ğ‘ ; âˆ’10^8 â‰¤ ğ‘¥ğ‘— â‰¤ 10^8 for all 0 â‰¤ ğ‘— < ğ‘.
Output Format: Output ğ‘ non-negative integers ğ‘˜0, ğ‘˜1, . . . , ğ‘˜ğ‘âˆ’1 where ğ‘˜ğ‘– is the number of segments which contain ğ‘¥ğ‘–. More formally, ğ‘˜ğ‘– = |{ğ‘— : ğ‘ğ‘— â‰¤ ğ‘¥ğ‘– â‰¤ ğ‘ğ‘—}|.



Closet Points
=============
Given ğ‘› points on a plane, find the smallest distance between a pair of two (different) points.
Input Format: The first line contains the number ğ‘› of points. Each of the following ğ‘› lines defines a point (ğ‘¥ğ‘–, ğ‘¦ğ‘–).
Constraints: 2 â‰¤ ğ‘› â‰¤ 10^5; âˆ’10^9 â‰¤ ğ‘¥ğ‘–, ğ‘¦ğ‘– â‰¤ 10^9 are integers.
Output Format: Output the minimum distance.



