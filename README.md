# Algorithms



Maximum Pairwise Product
========================
Find the maximum product of two distinct numbers in a sequence of non-negative integers.
Input: A sequence of non-negative integers.
Output: The maximum value that can be obtained by multiplying two different elements from the sequence.
Input format: The first line contains an integer ğ‘›. The next line contains n non-negative integers a1, ..., an (separated by spaces).
Output format: The maximum pairwise product.
Constraints: 2 < ğ‘› < 2 *10^5; 0 < a1, ..., an < 2*10^5.



Fibonacci Number
================
Given an integer ğ‘›, find the ğ‘›th Fibonacci number ğ¹ğ‘›.
Input Format: The input consists of a single integer ğ‘›.
Constraints: 0 â‰¤ ğ‘› â‰¤ 45.
Output Format: Output ğ¹ğ‘›.



Last Digit of a Large Fibonacci Number
======================================
Given an integer ğ‘›, find the last digit of the ğ‘›th Fibonacci number ğ¹ğ‘› (that is, ğ¹ğ‘› mod 10).
Input Format: The input consists of a single integer ğ‘›.
Constraints: 0 â‰¤ ğ‘› â‰¤ 10^7.
Output Format: Output the last digit of ğ¹ğ‘›.



Greatest Common Divisor
=======================
Given two integers ğ‘ and ğ‘, find their greatest common divisor.
Input Format: The two integers ğ‘, ğ‘ are given in the same line separated by space.
Constraints: 1 â‰¤ ğ‘, ğ‘ â‰¤ 2 Â· 10^9.
Output Format: Output GCD(ğ‘, ğ‘).



Least Common Multiple
=====================
Given two integers ğ‘ and ğ‘, find their least common multiple.
Input Format: The two integers ğ‘ and ğ‘ are given in the same line separated by space.
Constraints: 1 â‰¤ ğ‘, ğ‘ â‰¤ 10^7.
Output Format: Output the least common multiple of ğ‘ and ğ‘.




Fibonacci Number mode ğ‘š
========================
Given two integers ğ‘› and ğ‘š, output ğ¹ğ‘› mod ğ‘š (that is, the remainder of ğ¹ğ‘› when divided by ğ‘š).
Input Format: The input consists of two integers ğ‘› and ğ‘š given on the same line (separated by a space).
Constraints: 1 â‰¤ ğ‘› â‰¤ 10^14, 2 â‰¤ ğ‘š â‰¤ 10^3.
Output Format: Output ğ¹ğ‘› mod ğ‘š.



Last Digit of the Sum of Fibonacci Numbers
==========================================
Given an integer ğ‘›, find the last digit of the sum ğ¹0 + ğ¹1 + Â· Â· Â· + ğ¹ğ‘›.
Input Format: The input consists of a single integer ğ‘›.
Constraints: 0 â‰¤ ğ‘› â‰¤ 10^14.
Output Format: Output the last digit of ğ¹0 + ğ¹1 + Â· Â· Â· + ğ¹ğ‘›.



Last Digit of the Sum of Fibonacci Numbers
==========================================
Given two non-negative integers ğ‘š and ğ‘›, where ğ‘š â‰¤ ğ‘›, find the last digit of the sum ğ¹ğ‘š + ğ¹ğ‘š+1 + Â· Â· Â· + ğ¹ğ‘›.
Input Format: The input consists of two non-negative integers ğ‘š and ğ‘› separated by a space.
Constraints: 0 â‰¤ ğ‘š â‰¤ ğ‘› â‰¤ 10^14.
Output Format: Output the last digit of ğ¹ğ‘š + ğ¹ğ‘š+1 + Â· Â· Â· + ğ¹ğ‘›.




Last Digit of the Sum of Squares of Fibonacci Numbers
=====================================================
Compute the last digit of ğ¹0^2 + ğ¹1^2 + Â· Â· Â· + ğ¹ğ‘›^2.
Input Format: Integer ğ‘›.
Constraints: 0 â‰¤ ğ‘› â‰¤ 10^14.
Output Format: The last digit of ğ¹0^2 + ğ¹1^2 + Â· Â· Â· + ğ¹ğ‘›^2.



Money Change
============
Finding the minimum number of coins needed to change the input value (an integer) into coins with denominations 1, 5, and 10.
Input Format: The input consists of a single integer ğ‘š.
Constraints: 1 â‰¤ ğ‘š â‰¤ 10^3.
Output Format: Output the minimum number of coins with denominations 1, 5, 10 that changes ğ‘š.



Fractional Knapsack
===================
Input Format: The first line of the input contains the number ğ‘› of items and the capacity ğ‘Š of a knapsack. The next ğ‘› lines define the values and weights of the items. The ğ‘–-th line contains integers ğ‘£ğ‘– and ğ‘¤ğ‘– â€” the value and the weight of ğ‘–-th item, respectively.
Constraints: 1 â‰¤ ğ‘› â‰¤ 10^3, 0 â‰¤ ğ‘Š â‰¤ 2*10^6; 0 â‰¤ ğ‘£ğ‘– â‰¤ 2*10^6, 0 < ğ‘¤ğ‘– â‰¤ 2*10^6 for all 1 â‰¤ ğ‘– â‰¤ ğ‘›. All the numbers are integers.
Output Format: Output the maximal value of fractions of items that fit into the knapsack.



Car Fueling
===========
the minimum number of refills needed to travel to another city that is located ğ‘‘ miles away. Your car can travel at most ğ‘š miles on a full tank and you start with a full tank. Along your way, there are gas stations at distances stop1, stop2, . . . , stopğ‘› from your home city.
Input Format: The first line contains an integer ğ‘‘. The second line contains an integer ğ‘š. The third line specifies an integer ğ‘›. Finally, the last line contains integers stop1, stop2, . . . , stopğ‘›.
Output Format: The minimum number of refills needed. If it is not possible to reach the destination, output âˆ’1.
Constraints: 1 â‰¤ ğ‘‘ â‰¤ 10^5. 1 â‰¤ ğ‘š â‰¤ 400. 1 â‰¤ ğ‘› â‰¤ 300. 0 < stop1 < stop2 < Â· Â· Â· < stopğ‘› < ğ‘‘.



Maximum Number of Prizes
========================
The goal is to represent a given positive integer ğ‘› as a sum of as many pairwise distinct positive integers as possible. That is, to find the maximum ğ‘˜ such that ğ‘› can be written as ğ‘1 + ğ‘2 + Â· Â· Â· + ğ‘ğ‘˜ where ğ‘1, . . . , ğ‘ğ‘˜ are positive integers and ğ‘ğ‘– Ì¸= ğ‘ğ‘— for all 1 â‰¤ ğ‘– < ğ‘— â‰¤ ğ‘˜.
Input Format: The input consists of a single integer ğ‘›.
Constraints: 1 â‰¤ ğ‘› â‰¤ 10^9.
Output Format: In the first line, output the maximum number ğ‘˜ such that ğ‘› can be represented as a sum of ğ‘˜ pairwise distinct positive integers. In the second line, output ğ‘˜ pairwise distinct positive integers that sum up to ğ‘›.



Largest Number
==============
Composing the largest number out of the given single-digit numbers.
Input Format: The first line of the input contains integers ğ‘1, ğ‘2, . . . , ğ‘ğ‘›.
Constraints: 1 â‰¤ ğ‘› â‰¤ 100; 1 â‰¤ ğ‘ğ‘– â‰¤ 10^3 for all 1 â‰¤ ğ‘– â‰¤ ğ‘›.
Output Format: Output the largest number that can be composed out of ğ‘1, ğ‘2, . . . , ğ‘ğ‘›.



Binary Search
=============
The goal is to implement the binary search algorithm.
Input Format: The first line of the input contains an integer ğ‘› and a sequence ğ‘0 < ğ‘1 < . . . < ğ‘ğ‘›âˆ’1 of ğ‘› pairwise distinct positive integers in increasing order. The next line contains an integer ğ‘˜ and ğ‘˜ positive integers ğ‘0, ğ‘1, . . . , ğ‘ğ‘˜âˆ’1.
Constraints: 1 â‰¤ ğ‘˜ â‰¤ 10^5; 1 â‰¤ ğ‘› â‰¤ 3*10^4; 1 â‰¤ ğ‘ğ‘– â‰¤ 109 for all 0 â‰¤ ğ‘– < ğ‘›; 1 â‰¤ ğ‘ğ‘— â‰¤ 10^9 for all 0 â‰¤ ğ‘— < ğ‘˜;
Output Format: For all ğ‘– from 0 to ğ‘˜ âˆ’ 1, output an index 0 â‰¤ ğ‘— â‰¤ ğ‘› âˆ’ 1 such that ğ‘ğ‘— = ğ‘ğ‘– or âˆ’1 if there is no such index.



Majority Element
================
The goal is to check whether an input sequence contains a majority element, that is, repeated more than fifty percent.
Input Format: The first line contains an integer ğ‘›, the next one contains a sequence of ğ‘› non-negative integers ğ‘0, ğ‘1, . . . , ğ‘ğ‘›âˆ’1.
Constraints: 1 â‰¤ ğ‘› â‰¤ 10^5; 0 â‰¤ ğ‘ğ‘– â‰¤ 10^9 for all 0 â‰¤ ğ‘– < ğ‘›.
Output Format: Output 1 if the sequence contains an element that appears strictly more than ğ‘›/2 times, and 0 otherwise.



3-Way Quick Sort Algorithm
==========================
The goal is to replace a 2-way partition with a 3-way partition in quick sort algorithm. That is, the new partition procedure should partition the array into three parts: < ğ‘¥ part, = ğ‘¥ part, and > ğ‘¥ part.
Input Format: The first line of the input contains an integer ğ‘›. The next line contains a sequence of ğ‘› integers ğ‘0, ğ‘1, . . . , ğ‘ğ‘›âˆ’1.
Constraints: 1 â‰¤ ğ‘› â‰¤ 10^5; 1 â‰¤ ğ‘ğ‘– â‰¤ 10^9 for all 0 â‰¤ ğ‘– < ğ‘›.
Output Format: Output this sequence sorted in non-decreasing order.



Number of Inversions
====================
An inversion of a sequence ğ‘0, ğ‘1, . . . , ğ‘ğ‘›âˆ’1 is a pair of indices 0 â‰¤ ğ‘– < ğ‘— < ğ‘› such that ğ‘ğ‘– > ğ‘ğ‘— . For example, a sorted (in non-descending order) sequence contains no inversions at all, while in a sequence sorted in descending order any two elements constitute an inversion (for a total of ğ‘›(ğ‘› âˆ’ 1)/2 inversions).
The goal is to count the number of inversions of a given sequence.
Input Format: The first line contains an integer ğ‘›, the next one contains a sequence of integers ğ‘0, ğ‘1, . . . , ğ‘ğ‘›âˆ’1.
Constraints: 1 â‰¤ ğ‘› â‰¤ 10^5, 1 â‰¤ ğ‘ğ‘– â‰¤ 10^9 for all 0 â‰¤ ğ‘– < ğ‘›.
Output Format: Output the number of inversions in the sequence.



Points and Segments
===================
Given a set of points on a line and a set of segments on a line, the goal is to compute, for each point, the number of segments that contain this point.
Input Format: The first line contains two non-negative integers ğ‘  and ğ‘ defining the number of segments and the number of points on a line, respectively. The next ğ‘  lines contain two integers ğ‘ğ‘–, ğ‘ğ‘– defining the ğ‘–-th segment [ğ‘ğ‘–, ğ‘ğ‘–]. The next line contains ğ‘ integers defining points ğ‘¥1, ğ‘¥2, . . . , ğ‘¥ğ‘.
Constraints: 1 â‰¤ ğ‘ , ğ‘ â‰¤ 50000; âˆ’10^8 â‰¤ ğ‘ğ‘– â‰¤ ğ‘ğ‘– â‰¤ 10^8 for all 0 â‰¤ ğ‘– < ğ‘ ; âˆ’10^8 â‰¤ ğ‘¥ğ‘— â‰¤ 10^8 for all 0 â‰¤ ğ‘— < ğ‘.
Output Format: Output ğ‘ non-negative integers ğ‘˜0, ğ‘˜1, . . . , ğ‘˜ğ‘âˆ’1 where ğ‘˜ğ‘– is the number of segments which contain ğ‘¥ğ‘–. More formally, ğ‘˜ğ‘– = |{ğ‘— : ğ‘ğ‘— â‰¤ ğ‘¥ğ‘– â‰¤ ğ‘ğ‘—}|.



Closet Points
=============
Given ğ‘› points on a plane, find the smallest distance between a pair of two (different) points.
Input Format: The first line contains the number ğ‘› of points. Each of the following ğ‘› lines defines a point (ğ‘¥ğ‘–, ğ‘¦ğ‘–).
Constraints: 2 â‰¤ ğ‘› â‰¤ 10^5; âˆ’10^9 â‰¤ ğ‘¥ğ‘–, ğ‘¦ğ‘– â‰¤ 10^9 are integers.
Output Format: Output the minimum distance.



Money Change (Dynamic Programming)
==================================
The goal is to apply dynamic programming for solving the Money Change Problem for denominations 1, 3, and 4.
Input Format: Integer money.
Output Format: The minimum number of coins with denominations 1, 3, 4 that changes money.
Constraints: 1 â‰¤ money â‰¤ 10^3.



Primitive Calculator (Dynamic Programming)
==========================================
Given an integer ğ‘›, compute the minimum number of operations needed to obtain the number ğ‘› starting from the number 1 by performing the following three operations with the current number ğ‘¥: multiply ğ‘¥ by 2, multiply ğ‘¥ by 3, or add 1 to ğ‘¥.
Input Format: The input consists of a single integer 1 â‰¤ ğ‘› â‰¤ 10^6.
Output Format: In the first line, output the minimum number ğ‘˜ of operations needed to get ğ‘› from 1. In the second line output a sequence of intermediate numbers. That is, the second line would contain positive integers ğ‘0, ğ‘2, . . . , ğ‘ğ‘˜âˆ’1 such that ğ‘0 = 1, ğ‘ğ‘˜âˆ’1 = ğ‘› and for all 0 â‰¤ ğ‘– < ğ‘˜ âˆ’ 1, ğ‘ğ‘–+1 is equal to either ğ‘ğ‘– + 1, 2ğ‘ğ‘–, or 3ğ‘ğ‘–.



Edit Distance (Dynamic Programming)
===================================
The edit distance between two strings is the minimum number of operations (insertions, deletions, and substitutions of symbols) to transform one string into another. It is a measure of similarity of two strings. The goal is to implement the algorithm for computing the edit distance between two strings.
Input Format: Each of the two lines of the input contains a string consisting of lower case latin letters.
Constraints: The length of both strings is at least 1 and at most 100.
Output Format: Output the edit distance between the given two strings.



Longest Common Subsequence of Two Sequences (Dynamic Programming)
=================================================================
Given two sequences ğ´ = (ğ‘1, ğ‘2, . . . , ğ‘ğ‘›) and ğµ = (ğ‘1, ğ‘2, . . . , ğ‘ğ‘š), finding the length of their longest common subsequence, i.e., the largest non-negative integer ğ‘ such that there exist indices 1 â‰¤ ğ‘–1 < ğ‘–2 < Â· Â· Â· < ğ‘–ğ‘ â‰¤ ğ‘› and 1 â‰¤ ğ‘—1 < ğ‘—2 < Â· Â· Â· < ğ‘—ğ‘ â‰¤ ğ‘š, such that ğ‘ğ‘–1 = ğ‘ğ‘—1 , . . . , ğ‘ğ‘–ğ‘ = ğ‘ğ‘—ğ‘.
Input Format: First line: ğ‘›. Second line: ğ‘1, ğ‘2, . . . , ğ‘ğ‘›. Third line: ğ‘š. Fourth line: ğ‘1, ğ‘2, . . . , ğ‘ğ‘š.
Constraints: 1 â‰¤ ğ‘›,ğ‘š â‰¤ 100; âˆ’10^9 < ğ‘ğ‘–, ğ‘ğ‘– < 10^9.
Output Format: Output ğ‘.



Longest Common Subsequence of Three Sequences (Dynamic Programming)
===================================================================
Given three sequences ğ´ = (ğ‘1, ğ‘2, . . . , ğ‘ğ‘›), ğµ = (ğ‘1, ğ‘2, . . . , ğ‘ğ‘š), and ğ¶ = (ğ‘1, ğ‘2, . . . , ğ‘ğ‘™), finding the length of their longest common subsequence, i.e., the largest non-negative integer ğ‘ such that there exist indices 1 â‰¤ ğ‘–1 < ğ‘–2 < Â· Â· Â· < ğ‘–ğ‘ â‰¤ ğ‘›, 1 â‰¤ ğ‘—1 < ğ‘—2 < Â· Â· Â· < ğ‘—ğ‘ â‰¤ ğ‘š, 1 â‰¤ ğ‘˜1 < ğ‘˜2 < Â· Â· Â· < ğ‘˜ğ‘ â‰¤ ğ‘™ such that ğ‘ğ‘–1 = ğ‘ğ‘—1 = ğ‘ğ‘˜1 , . . . , ğ‘ğ‘–ğ‘ = ğ‘ğ‘—ğ‘ = ğ‘ğ‘˜ğ‘
Input Format: First line: ğ‘›. Second line: ğ‘1, ğ‘2, . . . , ğ‘ğ‘›. Third line: ğ‘š. Fourth line: ğ‘1, ğ‘2, . . . , ğ‘ğ‘š. Fifth line: ğ‘™. Sixth line: ğ‘1, ğ‘2, . . . , ğ‘ğ‘™.
Constraints: 1 â‰¤ ğ‘›, ğ‘š, ğ‘™ â‰¤ 100; âˆ’10^9 < ğ‘ğ‘–, ğ‘ğ‘–, ğ‘ğ‘– < 10^9.
Output Format: Output ğ‘.



Knapsack without Repetitions (Dynamic Programming)
==================================================
Given ğ‘› items, find the maximum weight of items fits into a bag of capacity ğ‘Š.
Input Format: The first line of the input contains the capacity ğ‘Š of a knapsack and the number ğ‘› of items of similar value. The next line contains ğ‘› integers ğ‘¤0,ğ‘¤1, . . . ,ğ‘¤ğ‘›âˆ’1 defining the weights of the items.
Constraints: 1 â‰¤ ğ‘Š â‰¤ 10^4; 1 â‰¤ ğ‘› â‰¤ 300; 0 â‰¤ ğ‘¤0, . . . ,ğ‘¤ğ‘›âˆ’1 â‰¤ 10^5.
Output Format: Output the maximum weight of gold that fits into a knapsack of capacity ğ‘Š.


Partitioning (Dynamic Programming)
==================================
The goal is to evenly split all the items with different values into three subsets with equal sums.
Problem Description
Input Format: The first line contains an integer ğ‘›. The second line contains integers ğ‘£1, ğ‘£2, . . . , ğ‘£ğ‘› separated by spaces.
Constraints: 1 â‰¤ ğ‘› â‰¤ 20, 1 â‰¤ ğ‘£ğ‘– â‰¤ 30 for all ğ‘–.
Output Format: Output 1, if it possible to partition ğ‘£1, ğ‘£2, . . . , ğ‘£ğ‘› into three subsets with equal sums, and 0 otherwise.



Maximum Value of an Arithmetic Expression (Dynamic Programming)
===============================================================
Finding the maximum value of an arithmetic expression by specifying the order of applying its arithmetic operations using additional parentheses.
Input Format: The only line of the input contains a string ğ‘  of length 2ğ‘› + 1 for some ğ‘›, with symbols ğ‘ 0, ğ‘ 1, . . . , ğ‘ 2ğ‘›. Each symbol at an even position of ğ‘  is a digit (that is, an integer from 0 to 9) while each symbol at an odd position is one of three operations from {+,-,*}.
Constraints: 0 â‰¤ ğ‘› â‰¤ 1000.
Output Format: Output the maximum possible value of the given arithmetic expression among different orders of applying arithmetic operations.
